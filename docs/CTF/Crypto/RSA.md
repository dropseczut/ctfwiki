# RSA

## 数论基础

**素数**，也称质数，是指大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1和该数本身两个正因数的数）。

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数`互素`。比如，15和32没有公因子，所以它们互素。这说明，不是素数也可以互素。

### 欧拉函数

欧拉函数是小于n的正整数中与n互素的数的数目，记为$\varphi(n) $。比如，在1-8中，与8互素的数是1、3、5、7，所以$\varphi(8)=4 $。

如果n=1，则$\varphi(1)=1$；

如果n是素数，则$\varphi(n)=n-1$；

如果n可以分解成两个素数的乘积，则$\varphi(n)=\varphi(pq)=\varphi(p)\varphi(q)$；

### 中国剩余定理

### 欧拉定理

### 模反元素

模逆元也称模倒数。

如果两个正整数a和n互素，那么一定可以找到整数b，满足

$$ab \equiv 1(\bmod \varphi(n))$$

## 密钥生成步骤

1. **随机选择两个不同的大素数`p`和`q`；**

   比如选择了61和53。（在实际应用中，两个素数非常大）

2. **计算`p`和`q`的乘积`n`，$n = p \times q$；**

   $n = 61 \times 53 = 3233$

3. **计算`n`的欧拉函数$\varphi(n) $，$\varphi(n)=(p-1)(q-1)$；**

   $\varphi(3233) = (61-1)(53-1) = 60 \times 52 = 3120$

4. **随机选择一个整数`e`，$1<e<\varphi(n)$，且`e`与$\varphi(n)$互素；**

   随机选择e=17。在实际应用中，常常选择65537。

5. **计算`e`对于$\varphi(n)$的模反元素`d`，$ed \equiv 1 (mod \varphi(n))$；**

   

6. **将n和e封装成公钥，n和d封装成私钥；销毁p、q**。

## 加密和解密

`m`表示明文，`c`表示密文，公钥记为`（n，e）`，私钥记为`（n，d）`

### 加密

$$c = m^e \bmod n$$

### 解密

$$m = c^d \bmod n$$

## 常见攻击方法

### 基本过程

- **已知p、q和e，求d**

```
p = 3487583947589437589237958723892346254777
q = 8767867843568934765983476584376578389
e = 65537
```

```python
import gmpy2
p = 3487583947589437589237958723892346254777
q = 8767867843568934765983476584376578389
e = 65537
phin = (p - 1) * (q - 1)
print(gmpy2.invert(e, phin))
```

- **已知p、q、e和c，求m**

```
p =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e =  65537
c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034
```

```python
import gmpy2

p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e =  65537
c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034

n = p * q
phin = (p -1) * (q - 1)
d = gmpy2.invert(e, phin)
# 解密
m = pow(c,d,n)
print(m)
```

- **已知p、q、dp、dq和c，求m**

```
p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229  
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469  
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929  
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041  
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852
```

```python
import gmpy2

p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

phin = gmpy2.invert(q,p)
mp = pow(c,dp,p)
mq = pow(c,dq,q)

m = (((mp-mq)*phin)%p)*q + mq
print(m)
```

### 模数分解

- 直接分解n

如果n比较小，可以通过工具直接分解n。

如果n大于768位，使用在线分解网站

- 利用公约数

### 低加密指数攻击

`e`称为加密指数

如果

```python
import gmpy2

e = 3
i = 0
while 1:
    tmp = gmpy2.iroot(c + i * N, e)
    if(tmp[1] == 1):
        print(long_to_bytes(tmp[0]))
        break
    i = i + 1
```



### 低加密指数广播攻击

### 低解密指数攻击

### 共模攻击

